"""
ì‹¤ìš©ì ì¸ Strands Agent SDK ê¸°ë°˜ ì›Œí¬í”Œë¡œìš°
ë³µì¡í•œ state ê´€ë¦¬ ì—†ì´ í•„ìš”í•œ ê¸°ëŠ¥ë§Œ í¬í•¨
"""

import asyncio
from typing import Dict, Any, Optional, List
from pathlib import Path
from datetime import datetime
import time
import json

from strands import Agent
from strands.session.file_session_manager import FileSessionManager

from .config import Config
from .models import ServiceType
from .tools import (
    load_frs_document,
    write_spec_file,
    create_git_branch,
    commit_changes,
    validate_markdown_structure,
    validate_openapi_spec
)
from .agents.spec_agents import (
    create_requirements_agent,
    create_design_agent,
    create_tasks_agent,
    create_changes_agent,
    create_openapi_agent,
    create_validation_agent,
    create_quality_assessor_agent,
    create_consistency_checker_agent,
    create_coordinator_agent
)
from .models.quality import (
    QualityReport,
    ConsistencyReport,
    ApprovalDecision,
)


class SpecificationWorkflow:
    """
    ì‹¤ìš©ì ì¸ ëª…ì„¸ì„œ ìƒì„± ì›Œí¬í”Œë¡œìš°
    
    ì£¼ìš” ê¸°ëŠ¥:
    - Strands Agent SDK ê¸°ë°˜ ì—ì´ì „íŠ¸ ì‹¤í–‰
    - ê°„ë‹¨í•œ ìƒíƒœ ê´€ë¦¬ (dict ì‚¬ìš©)
    - í’ˆì§ˆ í‰ê°€ ë° ê²€ì¦
    - Git í†µí•© (ì„ íƒì )
    - ì—ëŸ¬ í•¸ë“¤ë§ ë° ì¬ì‹œë„
    """
    
    def __init__(self, config: Optional[Config] = None):
        """ì›Œí¬í”Œë¡œìš° ì´ˆê¸°í™”"""
        self.config = config or Config.from_env()
        self.config.validate()
        
        # ê°„ë‹¨í•œ ìƒíƒœ ê´€ë¦¬
        self.context = {
            'project': {},
            'documents': {},
            'quality': {},
            'metrics': {}
        }
        
        # ì—ì´ì „íŠ¸ ì»¨í…Œì´ë„ˆ
        self.agents = {}
        
        # ì €ì¥ëœ íŒŒì¼ ëª©ë¡ ì¶”ì 
        self.saved_files = []
        
        # ì„¸ì…˜ ID
        self.session_id = f"spec_gen_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        print(f"âœ… ì›Œí¬í”Œë¡œìš° ì´ˆê¸°í™” ì™„ë£Œ (ì„¸ì…˜: {self.session_id})")
    
    def _initialize_agents(self):
        """ì—ì´ì „íŠ¸ ì´ˆê¸°í™”"""
        print("ğŸ¤– ì—ì´ì „íŠ¸ ì´ˆê¸°í™” ì¤‘...")
        
        # ì„¸ì…˜ ë§¤ë‹ˆì € ì„¤ì •
        self.session_manager = FileSessionManager(
            session_id=self.session_id,
            base_dir="./sessions"
        )
        
        # ê¸°ë³¸ ë¬¸ì„œ ìƒì„± ì—ì´ì „íŠ¸ë“¤
        self.agents = {
            'requirements': create_requirements_agent(self.config),
            'design': create_design_agent(self.config),
            'tasks': create_tasks_agent(self.config),
            'changes': create_changes_agent(self.config),
            'openapi': create_openapi_agent(self.config),
            'validation': create_validation_agent(self.config),
            # í’ˆì§ˆ í‰ê°€ ì—ì´ì „íŠ¸ë“¤
            'quality_assessor': create_quality_assessor_agent(self.config),
            'consistency_checker': create_consistency_checker_agent(self.config),
            'coordinator': create_coordinator_agent(self.config)
        }
        
        # ëª¨ë“  ì—ì´ì „íŠ¸ì— ì„¸ì…˜ ë§¤ë‹ˆì € ì—°ê²°
        for agent in self.agents.values():
            agent.session_manager = self.session_manager
        
        print(f"âœ… {len(self.agents)}ê°œ ì—ì´ì „íŠ¸ ì´ˆê¸°í™” ì™„ë£Œ (ì„¸ì…˜ ê´€ë¦¬ í¬í•¨)")
    
    async def execute_workflow(
        self,
        frs_path: str,
        service_type: ServiceType,
        output_dir: Optional[str] = None,
        use_git: bool = True
    ) -> Dict[str, Any]:
        """Graph ê¸°ë°˜ ì›Œí¬í”Œë¡œìš° ì‹¤í–‰"""
        
        start_time = time.time()
        
        try:
            # 1. FRS ë¡œë“œ ë° í”„ë¡œì íŠ¸ ì •ë³´ ì„¤ì •
            print(f"\nğŸ“– FRS ë¡œë“œ ì¤‘: {frs_path}")
            await self._initialize_project(frs_path, service_type, output_dir)
            
            # 2. Git ë¸Œëœì¹˜ ìƒì„± (ì„ íƒì )
            if use_git:
                await self._setup_git_branch()
            
            # 3. ì—ì´ì „íŠ¸ ì´ˆê¸°í™”
            self._initialize_agents()
            
            # 4. Graph ê¸°ë°˜ ì›Œí¬í”Œë¡œìš° ì‹¤í–‰
            print("\nğŸ”„ Graph ê¸°ë°˜ ì›Œí¬í”Œë¡œìš° ì‹œì‘...")
            graph_result = await self._execute_graph_workflow(service_type)
            
            # 5. ë¬¸ì„œ ì €ì¥ (ì´ë¯¸ ì €ì¥ëœ íŒŒì¼ ëª©ë¡ ìˆ˜ì§‘)
            print("\nğŸ’¾ ì €ì¥ëœ íŒŒì¼ ëª©ë¡ ìˆ˜ì§‘ ì¤‘...")
            files_written = await self._collect_saved_files()
            
            # 6. Git ì»¤ë°‹ (ì„ íƒì )
            if use_git and files_written:
                await self._commit_changes(files_written)
            
            # 7. ê²°ê³¼ ë°˜í™˜
            execution_time = time.time() - start_time
            
            return {
                "success": True,
                "session_id": self.session_id,
                "output_dir": self.context['project']['output_dir'],
                "files_written": files_written,
                "graph_result": graph_result,
                "execution_time": execution_time,
                "framework": "Strands Agent SDK - Graph"
            }
            
        except Exception as e:
            error_msg = f"ì›Œí¬í”Œë¡œìš° ì‹¤í–‰ ì‹¤íŒ¨: {str(e)}"
            print(f"âŒ {error_msg}")
            
            # ë¶€ë¶„ì ìœ¼ë¡œë¼ë„ ì €ì¥ëœ íŒŒì¼ì´ ìˆë‹¤ë©´ ë°˜í™˜
            partial_files = self.saved_files if hasattr(self, 'saved_files') else []
            
            return {
                "success": False,
                "session_id": self.session_id,
                "error": error_msg,
                "execution_time": time.time() - start_time,
                "files_written": partial_files,  # ë¶€ë¶„ ì„±ê³µí•œ íŒŒì¼ë“¤
                "partial_success": len(partial_files) > 0
            }
    
    async def _initialize_project(
        self, 
        frs_path: str,
        service_type: ServiceType,
        output_dir: Optional[str]
    ):
        """í”„ë¡œì íŠ¸ ì •ë³´ ì´ˆê¸°í™”"""
        # FRS ë¡œë“œ
        frs_result = load_frs_document(frs_path)
        if not frs_result.get("success"):
            raise ValueError(f"FRS ë¡œë“œ ì‹¤íŒ¨: {frs_path}")
        
        # FRS ID ì¶”ì¶œ
        frs_id = self._extract_frs_id(frs_path)
        
        # í”„ë¡œì íŠ¸ ì •ë³´ ì„¤ì •
        self.context['project'] = {
            'frs_path': frs_path,
            'frs_id': frs_id,
            'frs_content': frs_result.get("content", ""),
            'service_type': service_type.value,
            'output_dir': output_dir or f"specs/{frs_id}/{service_type.value}"
        }
        
        # ì¶œë ¥ ë””ë ‰í† ë¦¬ ìƒì„±
        output_path = Path(self.context['project']['output_dir'])
        output_path.mkdir(parents=True, exist_ok=True)
        print(f"ğŸ“ ì¶œë ¥ ë””ë ‰í† ë¦¬: {self.context['project']['output_dir']}")
    
    async def _setup_git_branch(self):
        """Git ë¸Œëœì¹˜ ì„¤ì •"""
        frs_id = self.context['project']['frs_id']
        service_type = self.context['project']['service_type']
        
        git_result = create_git_branch(frs_id, service_type)
        if git_result.get("success"):
            print(f"ğŸŒ¿ Git ë¸Œëœì¹˜: {git_result.get('branch_name')}")
        else:
            print(f"âš ï¸ Git ë¸Œëœì¹˜ ìƒì„± ì‹¤íŒ¨: {git_result.get('error')}")
    
    async def _execute_graph_workflow(self, service_type: ServiceType) -> Dict[str, Any]:
        """ë‹¨ìˆœí•œ ìˆœì°¨ ì—ì´ì „íŠ¸ ì‹¤í–‰ + í’ˆì§ˆ í‰ê°€"""
        
        print("ğŸ“Š ìˆœì°¨ ì›Œí¬í”Œë¡œìš° ì‹œì‘...")
        
        try:
            # ìµœëŒ€ 3íšŒ ì‹œë„
            for iteration in range(1, 4):
                print(f"\nğŸ”„ ì‹œë„ {iteration}/3")
                
                # 1ë‹¨ê³„: ê¸°ë³¸ ë¬¸ì„œ ìƒì„±
                documents = await self._generate_base_documents(service_type, iteration)
                
                if not documents:
                    print(f"âŒ {iteration}íšŒì°¨ ë¬¸ì„œ ìƒì„± ì‹¤íŒ¨")
                    continue
                
                # 2ë‹¨ê³„: í’ˆì§ˆ í‰ê°€
                quality_result = await self._evaluate_quality(documents, iteration)
                
                if quality_result.get('approved', False):
                    print(f"ğŸ‰ {iteration}íšŒì°¨ì—ì„œ ìŠ¹ì¸ ì™„ë£Œ!")
                    return {
                        'success': True,
                        'iteration': iteration,
                        'documents': documents,
                        'quality_result': quality_result,
                        'saved_files': list(documents.keys())
                    }
                else:
                    print(f"ğŸ”„ {iteration}íšŒì°¨ ê±°ë¶€: {quality_result.get('reason', 'í’ˆì§ˆ ê¸°ì¤€ ë¯¸ë‹¬')}")
                    if iteration < 3:
                        print("ğŸ“ í”¼ë“œë°±ì„ ë°˜ì˜í•˜ì—¬ ì¬ì‹œë„...")
            
            print("âŒ 3íšŒ ì‹œë„ í›„ì—ë„ í’ˆì§ˆ ê¸°ì¤€ ë¯¸ë‹¬")
            return {
                'success': False,
                'final_iteration': 3,
                'reason': 'ìµœëŒ€ ì‹œë„ íšŸìˆ˜ ì´ˆê³¼',
                'saved_files': list(documents.keys()) if 'documents' in locals() else []
            }
            
        except Exception as e:
            print(f"âŒ ì›Œí¬í”Œë¡œìš° ì‹¤íŒ¨: {str(e)}")
            import traceback
            traceback.print_exc()
            return {
                'success': False,
                'error': str(e),
                'saved_files': []
            }
    
    def _create_saving_agent_wrapper(self, agent_name: str):
        """íŒŒì¼ ì €ì¥ ê¸°ëŠ¥ì´ í¬í•¨ëœ ì—ì´ì „íŠ¸ ë˜í¼ ìƒì„±"""
        from strands import Agent
        
        original_agent = self.agents[agent_name]
        
        class SavingAgentWrapper:
            """ê²°ê³¼ë¥¼ ì¦‰ì‹œ íŒŒì¼ë¡œ ì €ì¥í•˜ëŠ” ì—ì´ì „íŠ¸ ë˜í¼"""
            
            def __init__(self, original_agent, workflow, agent_name):
                self.original_agent = original_agent
                self.workflow = workflow
                self.agent_name = agent_name
                # Agentì˜ ëª¨ë“  ì†ì„±ì„ ë˜í¼ì—ì„œë„ ì ‘ê·¼ ê°€ëŠ¥í•˜ê²Œ í•¨
                for attr in dir(original_agent):
                    if not attr.startswith('_') and not callable(getattr(original_agent, attr)):
                        setattr(self, attr, getattr(original_agent, attr))
            
            def __call__(self, prompt):
                """ì—ì´ì „íŠ¸ ì‹¤í–‰ ë° ì¦‰ì‹œ íŒŒì¼ ì €ì¥"""
                print(f"ğŸ”„ {self.agent_name} ì—ì´ì „íŠ¸ ì‹¤í–‰ ì¤‘...")
                
                # ì›ë³¸ ì—ì´ì „íŠ¸ ì‹¤í–‰
                result = self.original_agent(prompt)
                result_text = self.workflow._process_agent_result(self.agent_name, result)
                
                # ì¦‰ì‹œ íŒŒì¼ ì €ì¥ (ë™ê¸° í•¨ìˆ˜ë¡œ ë³€ê²½)
                try:
                    output_dir = self.workflow.context['project']['output_dir']
                    
                    # íŒŒì¼ëª… ê²°ì •
                    if self.agent_name == 'openapi':
                        filename = 'apis.json'
                    else:
                        filename = f'{self.agent_name}.md'
                    
                    # íŒŒì¼ ì €ì¥ (ë™ê¸° ë²„ì „ ì‚¬ìš©)
                    from pathlib import Path
                    file_path = Path(output_dir) / filename
                    file_path.parent.mkdir(parents=True, exist_ok=True)
                    
                    # ê¸°ì¡´ íŒŒì¼ ì¡´ì¬ ì—¬ë¶€ í™•ì¸
                    is_update = file_path.exists()
                    action = "ì—…ë°ì´íŠ¸" if is_update else "ìƒì„±"
                    
                    with open(file_path, 'w', encoding='utf-8') as f:
                        f.write(result_text)
                    file_size = file_path.stat().st_size
                    
                    print(f"  ğŸ“ {filename} {action} ì™„ë£Œ ({file_size} bytes)")
                    print(f"     ğŸ’¾ ìœ„ì¹˜: {file_path}")
                    
                    # ì €ì¥ëœ íŒŒì¼ ëª©ë¡ì— ì¶”ê°€ (ì¤‘ë³µ ë°©ì§€)
                    file_path_str = str(file_path)
                    if file_path_str not in self.workflow.saved_files:
                        self.workflow.saved_files.append(file_path_str)
                
                except Exception as e:
                    print(f"  âŒ {self.agent_name} íŒŒì¼ ì €ì¥ ì‹¤íŒ¨: {str(e)}")
                
                print(f"âœ… {self.agent_name} ì™„ë£Œ")
                return result_text
            
            def __getattr__(self, name):
                """ì›ë³¸ ì—ì´ì „íŠ¸ì˜ ì†ì„±ì— ì ‘ê·¼"""
                return getattr(self.original_agent, name)
        
        return SavingAgentWrapper(original_agent, self, agent_name)
    
    def _need_revision(self, state) -> bool:
        """í’ˆì§ˆ í‰ê°€ ê²°ê³¼ ê¸°ë°˜ ì¬ì‘ì—… í•„ìš” ì—¬ë¶€ íŒë‹¨"""
        try:
            # Graphì˜ stateì—ì„œ coordinator ì¶œë ¥ í™•ì¸
            # Strands GraphëŠ” ë§ˆì§€ë§‰ ë…¸ë“œì˜ ì¶œë ¥ì„ ì§ì ‘ ì „ë‹¬í•  ìˆ˜ ìˆìŒ
            coordinator_output = state
            
            # coordinatorê°€ JSON í˜•íƒœë¡œ ê²°ê³¼ë¥¼ ë°˜í™˜í•œë‹¤ê³  ê°€ì •
            if isinstance(coordinator_output, str):
                try:
                    decision_data = json.loads(coordinator_output)
                    approved = decision_data.get('approved', False)
                    
                    if not approved:
                        print(f"ğŸ”„ ì¬ì‘ì—… í•„ìš”: {decision_data.get('reason', 'í’ˆì§ˆ ê¸°ì¤€ ë¯¸ë‹¬')}")
                        return True
                    else:
                        print(f"âœ… ìµœì¢… ìŠ¹ì¸: {decision_data.get('reason', 'í’ˆì§ˆ ê¸°ì¤€ ì¶©ì¡±')}")
                        return False
                        
                except json.JSONDecodeError:
                    print("âš ï¸ coordinator ê²°ê³¼ íŒŒì‹± ì‹¤íŒ¨")
                    return False
            
            # ê¸°ë³¸ì ìœ¼ë¡œ ìŠ¹ì¸ìœ¼ë¡œ ê°„ì£¼
            print("âœ… ê¸°ë³¸ ìŠ¹ì¸ (ê²°ê³¼ íŒŒì‹± ë¶ˆê°€)")
            return False
                
        except Exception as e:
            print(f"âš ï¸ ì¬ì‘ì—… íŒì • ì¤‘ ì˜¤ë¥˜: {str(e)}")
            return False
    
    async def _execute_fallback_workflow(self, service_type: ServiceType) -> Dict[str, Any]:
        """Graph ì‹¤í–‰ ì‹¤íŒ¨ì‹œ fallback ì›Œí¬í”Œë¡œìš°"""
        print("ğŸ”„ Fallback ì›Œí¬í”Œë¡œìš°ë¡œ ì „í™˜...")
        
        # ê¸°ë³¸ ë¬¸ì„œ ìƒì„± ìˆœì„œ
        agent_sequence = ['requirements', 'design', 'tasks', 'changes']
        if service_type == ServiceType.API:
            agent_sequence.append('openapi')
        
        # í’ˆì§ˆ í‰ê°€ ì—ì´ì „íŠ¸ë“¤
        quality_agents = ['quality_assessor', 'consistency_checker', 'coordinator']
        
        # ìµœëŒ€ 3íšŒ ì‹œë„
        for iteration in range(1, 4):
            print(f"\nğŸ”„ ì‹œë„ {iteration}/3")
            
            # 1. ê¸°ë³¸ ë¬¸ì„œ ìƒì„±
            documents = {}
            for agent_name in agent_sequence:
                print(f"ğŸ”„ {agent_name} ì—ì´ì „íŠ¸ ì‹¤í–‰ ì¤‘...")
                result = await self._execute_agent(agent_name, {'iteration': iteration})
                if result:
                    documents[agent_name] = result
                    print(f"âœ… {agent_name} ì™„ë£Œ")
                else:
                    print(f"âŒ {agent_name} ì‹¤íŒ¨")
            
            # 2. í’ˆì§ˆ í‰ê°€
            print("\nğŸ“Š í’ˆì§ˆ í‰ê°€ ë‹¨ê³„...")
            quality_results = {}
            
            for agent_name in quality_agents:
                print(f"ğŸ”„ {agent_name} ì‹¤í–‰ ì¤‘...")
                # ì´ì „ ë¬¸ì„œë“¤ì„ ìƒíƒœë¡œ ì „ë‹¬
                state = {'results': documents, 'iteration': iteration}
                result = await self._execute_agent(agent_name, state)
                if result:
                    quality_results[agent_name] = result
                    print(f"âœ… {agent_name} ì™„ë£Œ")
            
            # 3. ìŠ¹ì¸ ì—¬ë¶€ í™•ì¸
            coordinator_result = quality_results.get('coordinator')
            if coordinator_result:
                try:
                    decision_data = json.loads(coordinator_result)
                    if decision_data.get('approved', False):
                        print(f"ğŸ‰ {iteration}íšŒì°¨ì—ì„œ ìŠ¹ì¸ ì™„ë£Œ!")
                        return {
                            'success': True,
                            'iteration': iteration,
                            'documents': documents,
                            'quality_results': quality_results
                        }
                    else:
                        print(f"ğŸ”„ {iteration}íšŒì°¨ ê±°ë¶€: {decision_data.get('reason', 'í’ˆì§ˆ ê¸°ì¤€ ë¯¸ë‹¬')}")
                        if iteration < 3:
                            print("ğŸ“ í”¼ë“œë°±ì„ ë°˜ì˜í•˜ì—¬ ì¬ì‹œë„...")
                            # ë‹¤ìŒ iterationì—ì„œ í”¼ë“œë°± í™œìš©
                except Exception as e:
                    print(f"âš ï¸ ìŠ¹ì¸ ê²°ê³¼ íŒŒì‹± ì‹¤íŒ¨: {str(e)}")
        
        print("âŒ 3íšŒ ì‹œë„ í›„ì—ë„ í’ˆì§ˆ ê¸°ì¤€ ë¯¸ë‹¬")
        return {
            'success': False,
            'final_iteration': 3,
            'reason': 'ìµœëŒ€ ì‹œë„ íšŸìˆ˜ ì´ˆê³¼'
        }
    
    async def _execute_agent(self, agent_name: str, state: Dict[str, Any] = None) -> Optional[str]:
        """ê°œë³„ ì—ì´ì „íŠ¸ ì‹¤í–‰ (async ë²„ì „)"""
        try:
            agent = self.agents.get(agent_name)
            if not agent:
                print(f"âŒ ì—ì´ì „íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ: {agent_name}")
                return None
            
            # í”„ë¡¬í”„íŠ¸ ìƒì„± (ìƒíƒœ ê¸°ë°˜)
            prompt = self._build_prompt_from_state(agent_name, state or {})
            
            # í’ˆì§ˆ í‰ê°€ ì—ì´ì „íŠ¸ë“¤ì€ structured output ì‚¬ìš©
            if agent_name in ['quality_assessor', 'consistency_checker', 'coordinator']:
                result = await self._execute_structured_agent(agent_name, agent, prompt)
            else:
                # ì¼ë°˜ ì—ì´ì „íŠ¸ëŠ” ë™ê¸° í˜¸ì¶œ (ainvoke ë©”ì„œë“œê°€ ì—†ìŒ)
                result = agent(prompt)
                result_text = self._process_agent_result(agent_name, result)
                
                # ì¦‰ì‹œ íŒŒì¼ ì €ì¥
                if result_text:
                    save_result = await self._save_agent_document(agent_name, result_text)
                    if save_result:
                        print(f"  ğŸ“ {save_result['filename']} ì €ì¥ ì™„ë£Œ")
                
                result = result_text
            
            return result
            
        except Exception as e:
            print(f"âŒ {agent_name} ì—ì´ì „íŠ¸ ì‹¤í–‰ ì˜¤ë¥˜: {str(e)}")
            return None
    
    async def _execute_structured_agent(self, agent_name: str, agent: Agent, prompt: str) -> str:
        """Structured Outputì„ ì‚¬ìš©í•˜ëŠ” ì—ì´ì „íŠ¸ ì‹¤í–‰"""
        try:
            if agent_name == 'quality_assessor':
                result = agent.structured_output(QualityReport, prompt)
                result_json = result.model_dump_json()
                print(f"  ğŸ“Š í’ˆì§ˆ í‰ê°€: ì „ì²´ {result.overall}ì ")
                return result_json
                
            elif agent_name == 'consistency_checker':
                result = agent.structured_output(ConsistencyReport, prompt)
                result_json = result.model_dump_json()
                print(f"  ğŸ” ì¼ê´€ì„± ê²€ì¦: {len(result.issues)}ê°œ ì´ìŠˆ ë°œê²¬ ({result.severity})")
                return result_json
                
            elif agent_name == 'coordinator':
                result = agent.structured_output(ApprovalDecision, prompt)
                result_json = result.model_dump_json()
                status = "ìŠ¹ì¸" if result.approved else "ê±°ë¶€"
                print(f"  ğŸ¯ ìµœì¢… ê²°ì •: {status} (ì‹ ë¢°ë„: {result.confidence}%)")
                return result_json
                
        except Exception as e:
            print(f"  âŒ {agent_name} structured output ì‹¤í–‰ ì‹¤íŒ¨: {str(e)}")
            # fallback: ì¼ë°˜ í˜¸ì¶œ
            result = agent(prompt)
            return self._extract_agent_result(result)
    
    def _extract_agent_result(self, result) -> str:
        """ì—ì´ì „íŠ¸ ê²°ê³¼ì—ì„œ í…ìŠ¤íŠ¸ ì¶”ì¶œ"""
        if hasattr(result, 'content'):
            return str(result.content)
        elif hasattr(result, 'message'):
            return str(result.message.get('content', ''))
        else:
            return str(result)
    
    def _build_prompt_from_state(self, agent_name: str, state: Dict[str, Any]) -> str:
        """ìƒíƒœ ê¸°ë°˜ ì—ì´ì „íŠ¸ë³„ í”„ë¡¬í”„íŠ¸ ìƒì„±"""
        # ìƒíƒœì—ì„œ ê¸°ë³¸ ì •ë³´ ì¶”ì¶œ
        frs_content = state.get('frs_content', self.context['project'].get('frs_content', ''))
        service_type = state.get('service_type', self.context['project'].get('service_type', ''))
        
        # ì´ì „ ê²°ê³¼ë“¤ ì¶”ì¶œ (Graph ìƒíƒœì—ì„œ)
        results = state.get('results', {})
        
        if agent_name == 'requirements':
            return self._build_requirements_prompt(frs_content, service_type, results)
        elif agent_name == 'design':
            return self._build_design_prompt(results.get('requirements', {}), service_type)
        elif agent_name == 'tasks':
            return self._build_tasks_prompt(results.get('design', {}))
        elif agent_name == 'changes':
            return self._build_changes_prompt(service_type)
        elif agent_name == 'openapi':
            return self._build_openapi_prompt(results.get('requirements', {}), results.get('design', {}))
        elif agent_name == 'quality_assessor':
            return self._build_quality_prompt(results)
        elif agent_name == 'consistency_checker':
            return self._build_consistency_prompt(results)
        elif agent_name == 'coordinator':
            return self._build_coordinator_prompt(results)
        
        return "ì‘ì—…ì„ ìˆ˜í–‰í•˜ì„¸ìš”."
    
    def _build_requirements_prompt(self, frs_content: str, service_type: str, results: Dict) -> str:
        """ìš”êµ¬ì‚¬í•­ ì—ì´ì „íŠ¸ í”„ë¡¬í”„íŠ¸"""
        # ì¬ì‘ì—…ì¸ ê²½ìš° ì´ì „ í”¼ë“œë°± í¬í•¨
        feedback_section = ""
        if 'coordinator' in results:
            try:
                coordinator_data = json.loads(results['coordinator'].get('content', '{}'))
                improvements = coordinator_data.get('required_improvements', [])
                if improvements:
                    feedback_section = f"""
ì´ì „ í”¼ë“œë°±:
{chr(10).join(f"- {improvement}" for improvement in improvements)}

ìœ„ í”¼ë“œë°±ì„ ë°˜ì˜í•˜ì—¬ ê°œì„ ëœ ìš”êµ¬ì‚¬í•­ì„ ì‘ì„±í•˜ì„¸ìš”.
"""
            except:
                pass
        
        return f"""ë‹¤ìŒ FRS ë¬¸ì„œë¥¼ ë¶„ì„í•˜ì—¬ ìƒì„¸í•œ requirements.mdë¥¼ ìƒì„±í•˜ì„¸ìš”:

FRS ë‚´ìš©:
{frs_content[:4000]}

ì„œë¹„ìŠ¤ ìœ í˜•: {service_type}

{feedback_section}

ìš”êµ¬ì‚¬í•­:
1. êµ¬ì¡°í™”ëœ requirements.md í˜•ì‹ìœ¼ë¡œ ì‘ì„±
2. ëª…í™•í•œ ìš”êµ¬ì‚¬í•­ ID ì²´ê³„ ì‚¬ìš© (REQ-001, REQ-002 ë“±)
3. ê¸°ëŠ¥/ë¹„ê¸°ëŠ¥/ê¸°ìˆ  ìš”êµ¬ì‚¬í•­ ë¶„ë¦¬
4. ìˆ˜ìš© ê¸°ì¤€ í¬í•¨
5. í•œêµ­ì–´ë¡œ ì‘ì„±"""
    
    def _build_design_prompt(self, requirements_result: Dict, service_type: str) -> str:
        """ì„¤ê³„ ì—ì´ì „íŠ¸ í”„ë¡¬í”„íŠ¸"""
        req_content = self._extract_content_from_result(requirements_result)[:3000]
        
        return f"""ë‹¤ìŒ ìš”êµ¬ì‚¬í•­ì„ ë°”íƒ•ìœ¼ë¡œ ìƒì„¸í•œ design.mdë¥¼ ìƒì„±í•˜ì„¸ìš”:

ìš”êµ¬ì‚¬í•­:
{req_content}

ì„œë¹„ìŠ¤ ìœ í˜•: {service_type}

ìš”êµ¬ì‚¬í•­:
1. ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜ ì„¤ê³„
2. Mermaid ì‹œí€€ìŠ¤ ë‹¤ì´ì–´ê·¸ë¨ í¬í•¨ (```mermaid ë¸”ë¡)
3. ë°ì´í„° ëª¨ë¸ ì •ì˜
4. API ê³„ì•½ ì„¤ê³„
5. ë³´ì•ˆ ë° ì„±ëŠ¥ ê³ ë ¤ì‚¬í•­
6. í•œêµ­ì–´ë¡œ ì‘ì„±"""
    
    def _build_tasks_prompt(self, design_result: Dict) -> str:
        """ì‘ì—… ì—ì´ì „íŠ¸ í”„ë¡¬í”„íŠ¸"""
        design_content = self._extract_content_from_result(design_result)[:3000]
        
        return f"""ë‹¤ìŒ ì„¤ê³„ë¥¼ ë°”íƒ•ìœ¼ë¡œ ìƒì„¸í•œ tasks.mdë¥¼ ìƒì„±í•˜ì„¸ìš”:

ì„¤ê³„:
{design_content}

ìš”êµ¬ì‚¬í•­:
1. Epic/Story/Task ê³„ì¸µ êµ¬ì¡°
2. ê° ì‘ì—…ì— ëŒ€í•œ ëª…í™•í•œ ì„¤ëª…
3. ì˜ˆìƒ ì‹œê°„ ë° ìš°ì„ ìˆœìœ„
4. DoD (Definition of Done) ì²´í¬ë¦¬ìŠ¤íŠ¸
5. ì˜ì¡´ì„± í‘œì‹œ
6. í•œêµ­ì–´ë¡œ ì‘ì„±"""
    
    def _build_changes_prompt(self, service_type: str) -> str:
        """ë³€ê²½ì‚¬í•­ ì—ì´ì „íŠ¸ í”„ë¡¬í”„íŠ¸"""
        return f"""í”„ë¡œì íŠ¸ ë°°í¬ë¥¼ ìœ„í•œ ìƒì„¸í•œ changes.mdë¥¼ ìƒì„±í•˜ì„¸ìš”:

ì„œë¹„ìŠ¤ ìœ í˜•: {service_type}

ìš”êµ¬ì‚¬í•­:
1. ë²„ì „ ì´ë ¥
2. ë³€ê²½ ì‚¬í•­ ìš”ì•½
3. ì˜í–¥ë„ ë° ìœ„í—˜ ë¶„ì„
4. ë¡¤ë°± ê³„íš
5. ì•Œë ¤ì§„ ì´ìŠˆ
6. í•œêµ­ì–´ë¡œ ì‘ì„±"""
    
    def _build_openapi_prompt(self, requirements_result: Dict, design_result: Dict) -> str:
        """OpenAPI ì—ì´ì „íŠ¸ í”„ë¡¬í”„íŠ¸"""
        req_content = self._extract_content_from_result(requirements_result)[:2000]
        design_content = self._extract_content_from_result(design_result)[:2000]
        
        return f"""OpenAPI 3.1 ëª…ì„¸ë¥¼ JSON í˜•ì‹ìœ¼ë¡œ ìƒì„±í•˜ì„¸ìš”:

ìš”êµ¬ì‚¬í•­:
{req_content}

ì„¤ê³„:
{design_content}

ìš”êµ¬ì‚¬í•­:
1. ìœ íš¨í•œ JSON í˜•ì‹ (ë§ˆí¬ë‹¤ìš´ ë¸”ë¡ ì—†ì´)
2. OpenAPI 3.1 ìŠ¤í™ ì¤€ìˆ˜
3. 5-10ê°œì˜ í•µì‹¬ ì—”ë“œí¬ì¸íŠ¸
4. ìš”ì²­/ì‘ë‹µ ìŠ¤í‚¤ë§ˆ í¬í•¨
5. ì¸ì¦ ë° ì˜¤ë¥˜ ì²˜ë¦¬
6. JSONë§Œ ì¶œë ¥ (ì„¤ëª… ì—†ìŒ)"""
    
    def _build_quality_prompt(self, results: Dict) -> str:
        """í’ˆì§ˆ í‰ê°€ ì—ì´ì „íŠ¸ í”„ë¡¬í”„íŠ¸"""
        documents = []
        for name, result in results.items():
            if name in ['requirements', 'design', 'tasks', 'changes', 'openapi']:
                content = self._extract_content_from_result(result)
                documents.append(f"=== {name.upper()} ===\n{content[:1500]}")
        
        docs_text = "\n\n".join(documents)
        
        return f"""ë‹¤ìŒ ìƒì„±ëœ ë¬¸ì„œë“¤ì„ í’ˆì§ˆ í‰ê°€í•˜ì„¸ìš”:

{docs_text}

ê° í•­ëª©ì„ 0-100ì ìœ¼ë¡œ í‰ê°€í•˜ê³  JSON í˜•ì‹ìœ¼ë¡œ ì‘ë‹µí•˜ì„¸ìš”."""
    
    def _build_consistency_prompt(self, results: Dict) -> str:
        """ì¼ê´€ì„± ê²€ì¦ ì—ì´ì „íŠ¸ í”„ë¡¬í”„íŠ¸"""
        documents = []
        for name, result in results.items():
            if name in ['requirements', 'design', 'tasks', 'changes', 'openapi']:
                content = self._extract_content_from_result(result)
                documents.append(f"=== {name.upper()} ===\n{content[:1500]}")
        
        docs_text = "\n\n".join(documents)
        
        return f"""ë‹¤ìŒ ë¬¸ì„œë“¤ ê°„ì˜ ì¼ê´€ì„±ì„ ê²€ì¦í•˜ì„¸ìš”:

{docs_text}

êµì°¨ ì°¸ì¡°, ëª…ëª… ì¼ê´€ì„±, êµ¬ì¡°ì  ì¼ê´€ì„±ì„ í™•ì¸í•˜ê³  JSON í˜•ì‹ìœ¼ë¡œ ì‘ë‹µí•˜ì„¸ìš”."""
    
    def _build_coordinator_prompt(self, results: Dict) -> str:
        """ì½”ë””ë„¤ì´í„° ì—ì´ì „íŠ¸ í”„ë¡¬í”„íŠ¸"""
        quality_data = results.get('quality_assessor', {})
        consistency_data = results.get('consistency_checker', {})
        
        quality_content = self._extract_content_from_result(quality_data)
        consistency_content = self._extract_content_from_result(consistency_data)
        
        return f"""í’ˆì§ˆ í‰ê°€ì™€ ì¼ê´€ì„± ê²€ì¦ ê²°ê³¼ë¥¼ ë°”íƒ•ìœ¼ë¡œ ìµœì¢… ìŠ¹ì¸ ì—¬ë¶€ë¥¼ ê²°ì •í•˜ì„¸ìš”:

í’ˆì§ˆ í‰ê°€ ê²°ê³¼:
{quality_content}

ì¼ê´€ì„± ê²€ì¦ ê²°ê³¼:
{consistency_content}

ìŠ¹ì¸ ê¸°ì¤€ (ì „ì²´ í’ˆì§ˆ 85ì  ì´ìƒ, ì¼ê´€ì„± ì´ìŠˆ 5ê°œ ë¯¸ë§Œ, high ì‹¬ê°ë„ ì´ìŠˆ ì—†ìŒ)ì„ ë°”íƒ•ìœ¼ë¡œ JSON í˜•ì‹ìœ¼ë¡œ ê²°ì •í•˜ì„¸ìš”."""
    
    def _extract_content_from_result(self, result: Dict) -> str:
        """ê²°ê³¼ì—ì„œ ì»¨í…ì¸  ì¶”ì¶œ"""
        if isinstance(result, dict):
            return result.get('content', str(result))
        return str(result)
    
    def _process_agent_result(self, agent_name: str, result: Any) -> str:
        """ì—ì´ì „íŠ¸ ê²°ê³¼ ì²˜ë¦¬"""
        result_str = str(result)
        
        # OpenAPI JSONì¸ ê²½ìš° ë§ˆí¬ë‹¤ìš´ ë¸”ë¡ ì œê±°
        if agent_name == 'openapi':
            # ```json ë¸”ë¡ ì œê±°
            if result_str.startswith('```json'):
                result_str = result_str[7:]
            if result_str.startswith('```'):
                result_str = result_str[3:]
            if result_str.endswith('```'):
                result_str = result_str[:-3]
            result_str = result_str.strip()
        
        return result_str
    
    
    async def _save_agent_document(self, agent_name: str, content: str) -> Optional[Dict[str, Any]]:
        """ê°œë³„ ì—ì´ì „íŠ¸ ë¬¸ì„œ ì¦‰ì‹œ ì €ì¥ (ë¹„ë™ê¸° ë²„ì „)"""
        try:
            output_dir = self.context['project']['output_dir']
            
            # íŒŒì¼ëª… ê²°ì •
            if agent_name == 'openapi':
                filename = 'apis.json'
            else:
                filename = f'{agent_name}.md'
            
            # íŒŒì¼ ì €ì¥
            result = await write_spec_file(output_dir, content, filename)
            
            if result.get("success"):
                file_info = {
                    "filename": filename,
                    "file_path": result.get("file_path"),
                    "size": result.get("size", 0)
                }
                # ì €ì¥ëœ íŒŒì¼ ëª©ë¡ì— ì¶”ê°€
                self.saved_files.append(result.get("file_path"))
                return file_info
            else:
                print(f"  âŒ {filename} ì €ì¥ ì‹¤íŒ¨: {result.get('error')}")
                return None
                
        except Exception as e:
            print(f"  âŒ {agent_name} ë¬¸ì„œ ì €ì¥ ì¤‘ ì˜¤ë¥˜: {str(e)}")
            return None
    
    def _save_agent_document_sync(self, agent_name: str, content: str) -> Optional[Dict[str, Any]]:
        """ê°œë³„ ì—ì´ì „íŠ¸ ë¬¸ì„œ ì¦‰ì‹œ ì €ì¥ (ë™ê¸° ë²„ì „)"""
        try:
            output_dir = self.context['project']['output_dir']
            
            # íŒŒì¼ëª… ê²°ì •
            if agent_name == 'openapi':
                filename = 'apis.json'
            else:
                filename = f'{agent_name}.md'
            
            # íŒŒì¼ ê²½ë¡œ ì„¤ì •
            file_path = Path(output_dir) / filename
            file_path.parent.mkdir(parents=True, exist_ok=True)
            
            # ê¸°ì¡´ íŒŒì¼ ì¡´ì¬ ì—¬ë¶€ í™•ì¸
            is_update = file_path.exists()
            action = "ì—…ë°ì´íŠ¸" if is_update else "ìƒì„±"
            
            # íŒŒì¼ ì €ì¥
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(content)
            
            file_size = file_path.stat().st_size
            
            print(f"  ğŸ“ {filename} {action} ì™„ë£Œ ({file_size} bytes)")
            print(f"     ğŸ’¾ ìœ„ì¹˜: {file_path}")
            
            # ì €ì¥ëœ íŒŒì¼ ëª©ë¡ì— ì¶”ê°€ (ì¤‘ë³µ ë°©ì§€)
            file_path_str = str(file_path)
            if file_path_str not in self.saved_files:
                self.saved_files.append(file_path_str)
            
            return {
                "filename": filename,
                "file_path": file_path_str,
                "size": file_size,
                "action": action
            }
                
        except Exception as e:
            print(f"  âŒ {agent_name} ë¬¸ì„œ ì €ì¥ ì¤‘ ì˜¤ë¥˜: {str(e)}")
            return None
    
    async def _save_graph_results(self, graph_result: Any, service_type: ServiceType):
        """Graph ì‹¤í–‰ ê²°ê³¼ë¥¼ íŒŒì¼ë¡œ ì €ì¥"""
        try:
            print("ğŸ“Š Graph ê²°ê³¼ ë¶„ì„ ì¤‘...")
            
            # Graph ê²°ê³¼ì—ì„œ ë¬¸ì„œ ë‚´ìš© ì¶”ì¶œ
            # Strands GraphëŠ” ì‹¤í–‰ ì¤‘ ìƒì„±ëœ ëª¨ë“  ë…¸ë“œì˜ ê²°ê³¼ë¥¼ í¬í•¨í•  ìˆ˜ ìˆìŒ
            documents_to_save = ['requirements', 'design', 'tasks', 'changes']
            if service_type == ServiceType.API:
                documents_to_save.append('openapi')
            
            # Graph ê²°ê³¼ì—ì„œ ê° ë¬¸ì„œ ë‚´ìš© ì¶”ì¶œ ë° ì €ì¥
            for doc_type in documents_to_save:
                try:
                    # Graph ê²°ê³¼ëŠ” ë‹¤ì–‘í•œ í˜•íƒœì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì•ˆì „í•˜ê²Œ ì ‘ê·¼
                    content = self._extract_document_from_graph_result(graph_result, doc_type)
                    if content:
                        save_result = self._save_agent_document_sync(doc_type, content)
                        if save_result:
                            print(f"  ğŸ“ {save_result['filename']} {save_result['action']} ì™„ë£Œ")
                        else:
                            print(f"  âš ï¸ {doc_type} ì €ì¥ ì‹¤íŒ¨")
                    else:
                        print(f"  âš ï¸ {doc_type} ë‚´ìš©ì„ Graph ê²°ê³¼ì—ì„œ ì°¾ì„ ìˆ˜ ì—†ìŒ")
                except Exception as e:
                    print(f"  âŒ {doc_type} ì €ì¥ ì¤‘ ì˜¤ë¥˜: {str(e)}")
            
            print("âœ… Graph ê²°ê³¼ íŒŒì¼ ì €ì¥ ì™„ë£Œ")
            
        except Exception as e:
            print(f"âŒ Graph ê²°ê³¼ ì €ì¥ ì‹¤íŒ¨: {str(e)}")
    
    def _extract_document_from_graph_result(self, graph_result: Any, doc_type: str) -> str:
        """Graph ê²°ê³¼ì—ì„œ íŠ¹ì • ë¬¸ì„œ íƒ€ì…ì˜ ë‚´ìš© ì¶”ì¶œ"""
        try:
            # Graph ê²°ê³¼ê°€ ë¬¸ìì—´ì¸ ê²½ìš° (ìµœì¢… ì¶œë ¥)
            if isinstance(graph_result, str):
                return graph_result
            
            # Graph ê²°ê³¼ê°€ ë”•ì…”ë„ˆë¦¬ì¸ ê²½ìš°
            if isinstance(graph_result, dict):
                # ì§ì ‘ í‚¤ë¡œ ì ‘ê·¼
                if doc_type in graph_result:
                    return str(graph_result[doc_type])
                
                # ë„¤ìŠ¤íŒ…ëœ êµ¬ì¡°ì—ì„œ ì°¾ê¸°
                for key, value in graph_result.items():
                    if doc_type in key.lower():
                        return str(value)
            
            # ê¸°íƒ€ í˜•íƒœì˜ ê²°ê³¼ëŠ” ë¬¸ìì—´ë¡œ ë³€í™˜
            result_str = str(graph_result)
            if result_str and result_str != "None":
                return result_str
            
            return ""
            
        except Exception as e:
            print(f"  âš ï¸ {doc_type} ì¶”ì¶œ ì¤‘ ì˜¤ë¥˜: {str(e)}")
            return ""
    
    async def _collect_and_save_node_results(self, graph, service_type: ServiceType) -> List[str]:
        """Graphì˜ ê° ë…¸ë“œ ê²°ê³¼ë¥¼ ìˆ˜ì§‘í•˜ê³  íŒŒì¼ë¡œ ì €ì¥"""
        saved_files = []
        
        try:
            # Graph ê°ì²´ì—ì„œ ë…¸ë“œë³„ ê²°ê³¼ ì ‘ê·¼
            nodes_to_save = ['requirements', 'design', 'tasks', 'changes']
            if service_type == ServiceType.API:
                nodes_to_save.append('openapi')
            
            for node_name in nodes_to_save:
                try:
                    # Graphì˜ ë…¸ë“œì—ì„œ ê²°ê³¼ ê°€ì ¸ì˜¤ê¸°
                    node_result = self._get_node_result(graph, node_name)
                    
                    if node_result:
                        # ê²°ê³¼ í…ìŠ¤íŠ¸ ì²˜ë¦¬
                        processed_result = self._process_agent_result(node_name, node_result)
                        
                        # íŒŒì¼ ì €ì¥
                        save_result = self._save_agent_document_sync(node_name, processed_result)
                        if save_result:
                            saved_files.append(save_result['file_path'])
                            print(f"  ğŸ“ {save_result['filename']} {save_result['action']} ì™„ë£Œ")
                        else:
                            print(f"  âŒ {node_name} ì €ì¥ ì‹¤íŒ¨")
                    else:
                        print(f"  âš ï¸ {node_name} ë…¸ë“œ ê²°ê³¼ ì—†ìŒ")
                        
                except Exception as e:
                    print(f"  âŒ {node_name} ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: {str(e)}")
            
            print(f"âœ… ì´ {len(saved_files)}ê°œ íŒŒì¼ ì €ì¥ ì™„ë£Œ")
            return saved_files
            
        except Exception as e:
            print(f"âŒ ë…¸ë“œ ê²°ê³¼ ìˆ˜ì§‘ ì‹¤íŒ¨: {str(e)}")
            return saved_files
    
    def _get_node_result(self, graph, node_name: str):
        """Graphì—ì„œ íŠ¹ì • ë…¸ë“œì˜ ê²°ê³¼ ê°€ì ¸ì˜¤ê¸°"""
        try:
            # Graph ê°ì²´ì˜ ë‚´ë¶€ êµ¬ì¡°ì—ì„œ ë…¸ë“œ ê²°ê³¼ ì ‘ê·¼
            if hasattr(graph, 'nodes'):
                for node in graph.nodes:
                    if hasattr(node, 'node_id') and node.node_id == node_name:
                        if hasattr(node, 'result'):
                            return node.result
            
            # ë‹¤ë¥¸ ë°©ì‹ìœ¼ë¡œ ì ‘ê·¼ ì‹œë„
            if hasattr(graph, '_nodes'):
                node = graph._nodes.get(node_name)
                if node and hasattr(node, 'result'):
                    return node.result
            
            # ë§ˆì§€ë§‰ ì‹¤í–‰ ê²°ê³¼ì—ì„œ ì°¾ê¸°
            if hasattr(graph, 'last_execution_result'):
                return graph.last_execution_result
                
            return None
            
        except Exception as e:
            print(f"  âš ï¸ {node_name} ë…¸ë“œ ê²°ê³¼ ì ‘ê·¼ ì‹¤íŒ¨: {str(e)}")
            return None
    
    async def _generate_remaining_documents(self, requirements_content: str, service_type: ServiceType) -> List[str]:
        """requirements.mdë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë‚˜ë¨¸ì§€ ë¬¸ì„œë“¤ ìƒì„±"""
        saved_files = []
        
        try:
            # ë‚˜ë¨¸ì§€ ìƒì„±í•  ë¬¸ì„œë“¤
            remaining_agents = ['design', 'tasks', 'changes']
            if service_type == ServiceType.API:
                remaining_agents.append('openapi')
            
            current_content = {'requirements': requirements_content}
            
            for agent_name in remaining_agents:
                try:
                    print(f"ğŸ”„ {agent_name} ë¬¸ì„œ ìƒì„± ì¤‘...")
                    
                    # ì—ì´ì „íŠ¸ë³„ í”„ë¡¬í”„íŠ¸ ìƒì„±
                    prompt = self._build_agent_prompt_from_previous(agent_name, current_content, service_type.value)
                    
                    # ì—ì´ì „íŠ¸ ì‹¤í–‰
                    agent = self.agents[agent_name]
                    result = agent(prompt)
                    
                    # ê²°ê³¼ ì²˜ë¦¬
                    result_text = self._process_agent_result(agent_name, result)
                    current_content[agent_name] = result_text
                    
                    # íŒŒì¼ ì €ì¥
                    save_result = self._save_agent_document_sync(agent_name, result_text)
                    if save_result:
                        saved_files.append(save_result['file_path'])
                        print(f"  ğŸ“ {save_result['filename']} {save_result['action']} ì™„ë£Œ")
                    else:
                        print(f"  âŒ {agent_name} ì €ì¥ ì‹¤íŒ¨")
                    
                except Exception as e:
                    print(f"  âŒ {agent_name} ìƒì„± ì¤‘ ì˜¤ë¥˜: {str(e)}")
                    continue
            
            return saved_files
            
        except Exception as e:
            print(f"âŒ ë‚˜ë¨¸ì§€ ë¬¸ì„œ ìƒì„± ì‹¤íŒ¨: {str(e)}")
            return saved_files
    
    def _build_agent_prompt_from_previous(self, agent_name: str, previous_contents: Dict[str, str], service_type: str) -> str:
        """ì´ì „ ìƒì„± ê²°ê³¼ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì—ì´ì „íŠ¸ë³„ í”„ë¡¬í”„íŠ¸ ìƒì„±"""
        
        if agent_name == 'design':
            requirements = previous_contents.get('requirements', '')[:3000]
            return f"""ë‹¤ìŒ ìš”êµ¬ì‚¬í•­ì„ ë°”íƒ•ìœ¼ë¡œ ìƒì„¸í•œ design.mdë¥¼ ìƒì„±í•˜ì„¸ìš”:

ìš”êµ¬ì‚¬í•­:
{requirements}

ì„œë¹„ìŠ¤ ìœ í˜•: {service_type}

ìš”êµ¬ì‚¬í•­:
1. ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜ ì„¤ê³„
2. Mermaid ì‹œí€€ìŠ¤ ë‹¤ì´ì–´ê·¸ë¨ í¬í•¨ (```mermaid ë¸”ë¡)
3. ë°ì´í„° ëª¨ë¸ ì •ì˜
4. API ê³„ì•½ ì„¤ê³„
5. ë³´ì•ˆ ë° ì„±ëŠ¥ ê³ ë ¤ì‚¬í•­
6. í•œêµ­ì–´ë¡œ ì‘ì„±"""
        
        elif agent_name == 'tasks':
            design = previous_contents.get('design', '')[:3000]
            return f"""ë‹¤ìŒ ì„¤ê³„ë¥¼ ë°”íƒ•ìœ¼ë¡œ ìƒì„¸í•œ tasks.mdë¥¼ ìƒì„±í•˜ì„¸ìš”:

ì„¤ê³„:
{design}

ìš”êµ¬ì‚¬í•­:
1. Epic/Story/Task ê³„ì¸µ êµ¬ì¡°
2. ê° ì‘ì—…ì— ëŒ€í•œ ëª…í™•í•œ ì„¤ëª…
3. ì˜ˆìƒ ì‹œê°„ ë° ìš°ì„ ìˆœìœ„
4. DoD (Definition of Done) ì²´í¬ë¦¬ìŠ¤íŠ¸
5. ì˜ì¡´ì„± í‘œì‹œ
6. í•œêµ­ì–´ë¡œ ì‘ì„±"""
        
        elif agent_name == 'changes':
            return f"""í”„ë¡œì íŠ¸ ë°°í¬ë¥¼ ìœ„í•œ ìƒì„¸í•œ changes.mdë¥¼ ìƒì„±í•˜ì„¸ìš”:

ì„œë¹„ìŠ¤ ìœ í˜•: {service_type}

ìš”êµ¬ì‚¬í•­:
1. ë²„ì „ ì´ë ¥
2. ë³€ê²½ ì‚¬í•­ ìš”ì•½
3. ì˜í–¥ë„ ë° ìœ„í—˜ ë¶„ì„
4. ë¡¤ë°± ê³„íš
5. ì•Œë ¤ì§„ ì´ìŠˆ
6. í•œêµ­ì–´ë¡œ ì‘ì„±"""
        
        elif agent_name == 'openapi':
            requirements = previous_contents.get('requirements', '')[:2000]
            design = previous_contents.get('design', '')[:2000]
            return f"""OpenAPI 3.1 ëª…ì„¸ë¥¼ JSON í˜•ì‹ìœ¼ë¡œ ìƒì„±í•˜ì„¸ìš”:

ìš”êµ¬ì‚¬í•­:
{requirements}

ì„¤ê³„:
{design}

ìš”êµ¬ì‚¬í•­:
1. ìœ íš¨í•œ JSON í˜•ì‹ (ë§ˆí¬ë‹¤ìš´ ë¸”ë¡ ì—†ì´)
2. OpenAPI 3.1 ìŠ¤í™ ì¤€ìˆ˜
3. 5-10ê°œì˜ í•µì‹¬ ì—”ë“œí¬ì¸íŠ¸
4. ìš”ì²­/ì‘ë‹µ ìŠ¤í‚¤ë§ˆ í¬í•¨
5. ì¸ì¦ ë° ì˜¤ë¥˜ ì²˜ë¦¬
6. JSONë§Œ ì¶œë ¥ (ì„¤ëª… ì—†ìŒ)"""
        
        return "ì‘ì—…ì„ ìˆ˜í–‰í•˜ì„¸ìš”."
    
    async def _generate_base_documents(self, service_type: ServiceType, iteration: int) -> Dict[str, str]:
        """ê¸°ë³¸ ë¬¸ì„œë“¤ì„ ìˆœì°¨ì ìœ¼ë¡œ ìƒì„±í•˜ê³  ì¦‰ì‹œ ì €ì¥"""
        
        print(f"ğŸ“ ê¸°ë³¸ ë¬¸ì„œ ìƒì„± ì‹œì‘ (ì‹œë„ {iteration}íšŒì°¨)")
        
        # ì‹¤í–‰í•  ì—ì´ì „íŠ¸ ìˆœì„œ
        agent_sequence = ['requirements', 'design', 'tasks', 'changes']
        if service_type == ServiceType.API:
            agent_sequence.append('openapi')
        
        # FRS ë‚´ìš©
        frs_content = self.context['project']['frs_content']
        
        # ìˆœì°¨ ì‹¤í–‰
        documents = {}
        
        for i, agent_name in enumerate(agent_sequence):
            print(f"ğŸ”„ {agent_name} ({i+1}/{len(agent_sequence)}) ìƒì„± ì¤‘...")
            
            try:
                # í”„ë¡¬í”„íŠ¸ ìƒì„±
                prompt = self._build_sequential_prompt(agent_name, frs_content, service_type.value, documents, iteration)
                
                # ì—ì´ì „íŠ¸ ì‹¤í–‰
                agent = self.agents[agent_name]
                result = agent(prompt)
                result_text = self._process_agent_result(agent_name, result)
                
                # ê²°ê³¼ ì €ì¥
                documents[agent_name] = result_text
                
                # ì¦‰ì‹œ íŒŒì¼ ì €ì¥
                save_result = self._save_agent_document_sync(agent_name, result_text)
                if save_result:
                    print(f"  ğŸ“ {save_result['filename']} {save_result['action']} ì™„ë£Œ")
                else:
                    print(f"  âŒ {agent_name} ì €ì¥ ì‹¤íŒ¨")
                    
                print(f"âœ… {agent_name} ì™„ë£Œ")
                
            except Exception as e:
                print(f"âŒ {agent_name} ì‹¤í–‰ ì˜¤ë¥˜: {str(e)}")
                return {}  # í•˜ë‚˜ë¼ë„ ì‹¤íŒ¨í•˜ë©´ ì „ì²´ ì‹¤íŒ¨
        
        print(f"âœ… ê¸°ë³¸ ë¬¸ì„œ ìƒì„± ì™„ë£Œ ({len(documents)}ê°œ)")
        return documents
    
    def _build_sequential_prompt(self, agent_name: str, frs_content: str, service_type: str, previous_docs: Dict[str, str], iteration: int) -> str:
        """ìˆœì°¨ ì‹¤í–‰ì„ ìœ„í•œ ì—ì´ì „íŠ¸ë³„ í”„ë¡¬í”„íŠ¸ ìƒì„±"""
        
        # ì¬ì‘ì—…ì¸ ê²½ìš° ê°œì„  ë©”ì‹œì§€ ì¶”ê°€
        improvement_note = ""
        if iteration > 1:
            improvement_note = f"\n\nâš ï¸ ì´ì „ {iteration-1}íšŒì°¨ì—ì„œ í’ˆì§ˆ ê¸°ì¤€ ë¯¸ë‹¬ë¡œ ì¬ì‘ì„± ì¤‘ì…ë‹ˆë‹¤. ë” ë†’ì€ í’ˆì§ˆë¡œ ì‘ì„±í•´ì£¼ì„¸ìš”.\n"
        
        if agent_name == 'requirements':
            return f"""ë‹¤ìŒ FRS ë¬¸ì„œë¥¼ ë¶„ì„í•˜ì—¬ ìƒì„¸í•œ requirements.mdë¥¼ ìƒì„±í•˜ì„¸ìš”:

FRS ë‚´ìš©:
{frs_content[:4000]}

ì„œë¹„ìŠ¤ ìœ í˜•: {service_type}{improvement_note}

ìš”êµ¬ì‚¬í•­:
1. êµ¬ì¡°í™”ëœ requirements.md í˜•ì‹ìœ¼ë¡œ ì‘ì„±
2. ëª…í™•í•œ ìš”êµ¬ì‚¬í•­ ID ì²´ê³„ ì‚¬ìš© (REQ-001, REQ-002 ë“±)
3. ê¸°ëŠ¥/ë¹„ê¸°ëŠ¥/ê¸°ìˆ  ìš”êµ¬ì‚¬í•­ ë¶„ë¦¬
4. ìˆ˜ìš© ê¸°ì¤€ í¬í•¨
5. í•œêµ­ì–´ë¡œ ì‘ì„±"""
        
        elif agent_name == 'design':
            requirements = previous_docs.get('requirements', '')[:3000]
            return f"""ë‹¤ìŒ ìš”êµ¬ì‚¬í•­ì„ ë°”íƒ•ìœ¼ë¡œ ìƒì„¸í•œ design.mdë¥¼ ìƒì„±í•˜ì„¸ìš”:

ìš”êµ¬ì‚¬í•­:
{requirements}

ì„œë¹„ìŠ¤ ìœ í˜•: {service_type}{improvement_note}

ìš”êµ¬ì‚¬í•­:
1. ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜ ì„¤ê³„
2. Mermaid ì‹œí€€ìŠ¤ ë‹¤ì´ì–´ê·¸ë¨ í¬í•¨ (```mermaid ë¸”ë¡)
3. ë°ì´í„° ëª¨ë¸ ì •ì˜
4. API ê³„ì•½ ì„¤ê³„
5. ë³´ì•ˆ ë° ì„±ëŠ¥ ê³ ë ¤ì‚¬í•­
6. í•œêµ­ì–´ë¡œ ì‘ì„±"""
        
        elif agent_name == 'tasks':
            design = previous_docs.get('design', '')[:3000]
            return f"""ë‹¤ìŒ ì„¤ê³„ë¥¼ ë°”íƒ•ìœ¼ë¡œ ìƒì„¸í•œ tasks.mdë¥¼ ìƒì„±í•˜ì„¸ìš”:

ì„¤ê³„:
{design}{improvement_note}

ìš”êµ¬ì‚¬í•­:
1. Epic/Story/Task ê³„ì¸µ êµ¬ì¡°
2. ê° ì‘ì—…ì— ëŒ€í•œ ëª…í™•í•œ ì„¤ëª…
3. ì˜ˆìƒ ì‹œê°„ ë° ìš°ì„ ìˆœìœ„
4. DoD (Definition of Done) ì²´í¬ë¦¬ìŠ¤íŠ¸
5. ì˜ì¡´ì„± í‘œì‹œ
6. í•œêµ­ì–´ë¡œ ì‘ì„±"""
        
        elif agent_name == 'changes':
            return f"""í”„ë¡œì íŠ¸ ë°°í¬ë¥¼ ìœ„í•œ ìƒì„¸í•œ changes.mdë¥¼ ìƒì„±í•˜ì„¸ìš”:

ì„œë¹„ìŠ¤ ìœ í˜•: {service_type}{improvement_note}

ìš”êµ¬ì‚¬í•­:
1. ë²„ì „ ì´ë ¥
2. ë³€ê²½ ì‚¬í•­ ìš”ì•½
3. ì˜í–¥ë„ ë° ìœ„í—˜ ë¶„ì„
4. ë¡¤ë°± ê³„íš
5. ì•Œë ¤ì§„ ì´ìŠˆ
6. í•œêµ­ì–´ë¡œ ì‘ì„±"""
        
        elif agent_name == 'openapi':
            requirements = previous_docs.get('requirements', '')[:2000]
            design = previous_docs.get('design', '')[:2000]
            return f"""OpenAPI 3.1 ëª…ì„¸ë¥¼ JSON í˜•ì‹ìœ¼ë¡œ ìƒì„±í•˜ì„¸ìš”:

ìš”êµ¬ì‚¬í•­:
{requirements}

ì„¤ê³„:
{design}{improvement_note}

ìš”êµ¬ì‚¬í•­:
1. ìœ íš¨í•œ JSON í˜•ì‹ (ë§ˆí¬ë‹¤ìš´ ë¸”ë¡ ì—†ì´)
2. OpenAPI 3.1 ìŠ¤í™ ì¤€ìˆ˜
3. 5-10ê°œì˜ í•µì‹¬ ì—”ë“œí¬ì¸íŠ¸
4. ìš”ì²­/ì‘ë‹µ ìŠ¤í‚¤ë§ˆ í¬í•¨
5. ì¸ì¦ ë° ì˜¤ë¥˜ ì²˜ë¦¬
6. JSONë§Œ ì¶œë ¥ (ì„¤ëª… ì—†ìŒ)"""
        
        return "ì‘ì—…ì„ ìˆ˜í–‰í•˜ì„¸ìš”."
    
    async def _evaluate_quality(self, documents: Dict[str, str], iteration: int) -> Dict[str, Any]:
        """ìƒì„±ëœ ë¬¸ì„œë“¤ì˜ í’ˆì§ˆ í‰ê°€"""
        
        print(f"ğŸ“Š í’ˆì§ˆ í‰ê°€ ì‹œì‘ (ì‹œë„ {iteration}íšŒì°¨)")
        
        try:
            # 1. í’ˆì§ˆ í‰ê°€
            print("ğŸ” í’ˆì§ˆ í‰ê°€ ì¤‘...")
            quality_prompt = self._build_quality_evaluation_prompt(documents)
            quality_result = self.agents['quality_assessor'].structured_output(QualityReport, quality_prompt)
            print(f"  ğŸ“Š ì „ì²´ í’ˆì§ˆ: {quality_result.overall}ì ")
            
            # 2. ì¼ê´€ì„± ê²€ì¦
            print("ğŸ” ì¼ê´€ì„± ê²€ì¦ ì¤‘...")
            consistency_prompt = self._build_consistency_check_prompt(documents)
            consistency_result = self.agents['consistency_checker'].structured_output(ConsistencyReport, consistency_prompt)
            print(f"  ğŸ” ì¼ê´€ì„± ì´ìŠˆ: {len(consistency_result.issues)}ê°œ ({consistency_result.severity})")
            
            # 3. ìµœì¢… ìŠ¹ì¸ ê²°ì •
            print("ğŸ¯ ìµœì¢… ìŠ¹ì¸ ê²°ì • ì¤‘...")
            coordinator_prompt = self._build_coordinator_prompt(quality_result, consistency_result)
            approval_result = self.agents['coordinator'].structured_output(ApprovalDecision, coordinator_prompt)
            
            status = "ìŠ¹ì¸" if approval_result.approved else "ê±°ë¶€"
            print(f"  ğŸ¯ ìµœì¢… ê²°ì •: {status} (ì‹ ë¢°ë„: {approval_result.confidence}%)")
            
            return {
                'approved': approval_result.approved,
                'reason': approval_result.reason,
                'confidence': approval_result.confidence,
                'quality_score': quality_result.overall,
                'consistency_issues': len(consistency_result.issues),
                'improvements': approval_result.required_improvements,
                'quality_details': {
                    'completeness': quality_result.completeness,
                    'consistency': quality_result.consistency,
                    'clarity': quality_result.clarity,
                    'technical': quality_result.technical
                }
            }
            
        except Exception as e:
            print(f"âŒ í’ˆì§ˆ í‰ê°€ ì‹¤íŒ¨: {str(e)}")
            # í’ˆì§ˆ í‰ê°€ ì‹¤íŒ¨ ì‹œ ê¸°ë³¸ ìŠ¹ì¸
            return {
                'approved': True,
                'reason': f'í’ˆì§ˆ í‰ê°€ ì‹œìŠ¤í…œ ì˜¤ë¥˜ë¡œ ê¸°ë³¸ ìŠ¹ì¸ ({str(e)})',
                'confidence': 50,
                'quality_score': 70,
                'consistency_issues': 0,
                'improvements': []
            }
    
    def _build_quality_evaluation_prompt(self, documents: Dict[str, str]) -> str:
        """í’ˆì§ˆ í‰ê°€ í”„ë¡¬í”„íŠ¸ ìƒì„±"""
        docs_summary = []
        for name, content in documents.items():
            if content:
                docs_summary.append(f"=== {name.upper()} ===\n{content[:1500]}")
        
        docs_text = "\n\n".join(docs_summary)
        
        return f"""ë‹¤ìŒ ìƒì„±ëœ ë¬¸ì„œë“¤ì„ ì¢…í•©ì ìœ¼ë¡œ í‰ê°€í•˜ì„¸ìš”:

{docs_text}

í‰ê°€ ê¸°ì¤€:
- completeness (ì™„ì„±ë„): ìš”êµ¬ì‚¬í•­ì´ ëª¨ë‘ í¬í•¨ë˜ì–´ ìˆëŠ”ê°€?
- consistency (ì¼ê´€ì„±): ë¬¸ì„œ ê°„ ì¼ê´€ì„±ì´ ìœ ì§€ë˜ëŠ”ê°€?
- clarity (ëª…í™•ì„±): ë‚´ìš©ì´ ëª…í™•í•˜ê³  ì´í•´í•˜ê¸° ì‰¬ìš´ê°€?
- technical (ê¸°ìˆ ì„±): ê¸°ìˆ ì  ì„¸ë¶€ì‚¬í•­ì´ ì ì ˆí•œê°€?
- overall (ì „ì²´): ì¢…í•©ì ì¸ í’ˆì§ˆ ì ìˆ˜

ê° í•­ëª©ì„ 0-100ì ìœ¼ë¡œ í‰ê°€í•˜ê³  êµ¬ì²´ì ì¸ í”¼ë“œë°±ì„ ì œê³µí•˜ì„¸ìš”."""
    
    def _build_consistency_check_prompt(self, documents: Dict[str, str]) -> str:
        """ì¼ê´€ì„± ê²€ì¦ í”„ë¡¬í”„íŠ¸ ìƒì„±"""
        docs_summary = []
        for name, content in documents.items():
            if content:
                docs_summary.append(f"=== {name.upper()} ===\n{content[:1500]}")
        
        docs_text = "\n\n".join(docs_summary)
        
        return f"""ë‹¤ìŒ ë¬¸ì„œë“¤ ê°„ì˜ ì¼ê´€ì„±ì„ ê²€ì¦í•˜ì„¸ìš”:

{docs_text}

ê²€ì¦ í•­ëª©:
1. ìš”êµ¬ì‚¬í•­ IDì˜ ì¼ê´€ì„± (REQ-001 ë“±)
2. ìš©ì–´ì™€ ëª…ëª…ì˜ ì¼ê´€ì„±
3. ê¸°ìˆ  ìŠ¤íƒê³¼ ì•„í‚¤í…ì²˜ì˜ ì¼ê´€ì„±
4. ë°ì´í„° ëª¨ë¸ê³¼ API ìŠ¤í™ì˜ ì¼ê´€ì„±
5. ì‘ì—… ë¶„í•´ì™€ ì„¤ê³„ì˜ ì¼ê´€ì„±

ë°œê²¬ëœ ì¼ê´€ì„± ì´ìŠˆë¥¼ êµ¬ì²´ì ìœ¼ë¡œ ë‚˜ì—´í•˜ê³  ì‹¬ê°ë„ë¥¼ í‰ê°€í•˜ì„¸ìš”."""
    
    def _build_coordinator_prompt(self, quality_report: QualityReport, consistency_report: ConsistencyReport) -> str:
        """ì½”ë””ë„¤ì´í„° ìŠ¹ì¸ ê²°ì • í”„ë¡¬í”„íŠ¸ ìƒì„±"""
        return f"""í’ˆì§ˆ í‰ê°€ì™€ ì¼ê´€ì„± ê²€ì¦ ê²°ê³¼ë¥¼ ë°”íƒ•ìœ¼ë¡œ ìµœì¢… ìŠ¹ì¸ ì—¬ë¶€ë¥¼ ê²°ì •í•˜ì„¸ìš”:

í’ˆì§ˆ í‰ê°€ ê²°ê³¼:
- ì™„ì„±ë„: {quality_report.completeness}ì 
- ì¼ê´€ì„±: {quality_report.consistency}ì   
- ëª…í™•ì„±: {quality_report.clarity}ì 
- ê¸°ìˆ ì„±: {quality_report.technical}ì 
- ì „ì²´: {quality_report.overall}ì 

ì£¼ìš” í”¼ë“œë°±:
{chr(10).join(f"- {feedback}" for feedback in quality_report.feedback[:5])}

ì¼ê´€ì„± ê²€ì¦ ê²°ê³¼:
- ë°œê²¬ëœ ì´ìŠˆ: {len(consistency_report.issues)}ê°œ
- ì‹¬ê°ë„: {consistency_report.severity}
- ì£¼ìš” ì´ìŠˆ: {', '.join(consistency_report.issues[:3])}

ìŠ¹ì¸ ê¸°ì¤€:
- ì „ì²´ í’ˆì§ˆ 85ì  ì´ìƒ
- ì¼ê´€ì„± ì´ìŠˆ 5ê°œ ë¯¸ë§Œ
- high ì‹¬ê°ë„ ì´ìŠˆ ì—†ìŒ

ìœ„ ê¸°ì¤€ì„ ë°”íƒ•ìœ¼ë¡œ ìŠ¹ì¸/ê±°ë¶€ë¥¼ ê²°ì •í•˜ê³ , ê±°ë¶€ ì‹œ êµ¬ì²´ì ì¸ ê°œì„  ì‚¬í•­ì„ ì œì‹œí•˜ì„¸ìš”."""
    
    
    def _extract_requirement_ids(self, content: str) -> List[str]:
        """ìš”êµ¬ì‚¬í•­ ID ì¶”ì¶œ"""
        import re
        pattern = r'REQ-\d{3}'
        return re.findall(pattern, content)
    
    async def _collect_saved_files(self) -> List[str]:
        """ì €ì¥ëœ íŒŒì¼ ëª©ë¡ ìˆ˜ì§‘"""
        print(f"  ğŸ“ ì´ {len(self.saved_files)}ê°œ íŒŒì¼ì´ ì €ì¥ë¨")
        for file_path in self.saved_files:
            filename = Path(file_path).name
            print(f"    âœ… {filename}")
        return self.saved_files
    
    async def _commit_changes(self, files_written: List[str]):
        """Git ì»¤ë°‹"""
        frs_id = self.context['project']['frs_id']
        service_type = self.context['project']['service_type']
        
        result = commit_changes(frs_id, service_type, files_written)
        
        if result.get("success"):
            print(f"âœ… Git ì»¤ë°‹ ì™„ë£Œ: {result.get('commit_hash', '')[:8]}")
        else:
            print(f"âš ï¸ Git ì»¤ë°‹ ì‹¤íŒ¨: {result.get('error')}")
    
    def _extract_frs_id(self, frs_path: str) -> str:
        """FRS ID ì¶”ì¶œ"""
        import re
        match = re.search(r'FRS-(\d+)', frs_path)
        if match:
            return f"FRS-{match.group(1)}"
        return Path(frs_path).stem
    
    def validate_existing_specs(self, spec_dir: str) -> Dict[str, Any]:
        """ê¸°ì¡´ ëª…ì„¸ì„œ ê²€ì¦"""
        try:
            spec_path = Path(spec_dir)
            
            if not spec_path.exists() or not spec_path.is_dir():
                return {"success": False, "error": f"ë””ë ‰í† ë¦¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ: {spec_dir}"}
            
            validation_results = []
            files_to_validate = [
                "requirements.md",
                "design.md",
                "tasks.md",
                "changes.md",
                "apis.json"
            ]
            
            for file_name in files_to_validate:
                file_path = spec_path / file_name
                
                if file_path.exists():
                    # íŒŒì¼ ê²€ì¦
                    if file_name.endswith('.md'):
                        result = validate_markdown_structure(str(file_path))
                    elif file_name.endswith('.json'):
                        result = validate_openapi_spec(str(file_path))
                    else:
                        result = {"success": True}
                    
                    validation_results.append({
                        "file": file_name,
                        "exists": True,
                        "valid": result.get("success", False),
                        "error": result.get("error")
                    })
                else:
                    validation_results.append({
                        "file": file_name,
                        "exists": False,
                        "valid": False,
                        "error": "íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŒ"
                    })
            
            # ì „ì²´ ê²°ê³¼ ê³„ì‚°
            total_files = len(validation_results)
            valid_files = sum(1 for r in validation_results if r["valid"])
            
            return {
                "success": True,
                "validation_results": validation_results,
                "summary": {
                    "total_files": total_files,
                    "valid_files": valid_files,
                    "invalid_files": total_files - valid_files
                }
            }
            
        except Exception as e:
            return {"success": False, "error": str(e)}